eulerian_trail(paired_dB_graph)

1. initiate **final_path** list
2. get adjacent_list from paired_dB_graph
3. get start_node which is a node with IN == 0
4. append start_node into final_path

Enter loop to find the trail (contig)
while_loop_1. initiate trail list to record passed nodes
while_loop_2. initiate current_node with start_node

    Enter inner while loop
    inner_loop_1. (break point) check if current_node in adjacent_list
    inner_loop_2. find the next node linked to current_node, pop it and store it as next_node
    inner_loop_3. check if current_node has other linked nodes, if not, delete it from adjacent list
    inner_loop_4. record next_node: append next_node into trail
    inner_loop_5. (break point)check if next_node equal to start_node, if so, that's a loop, break inner while loop
    inner_loop_6. re-define current_node with next_node, repeat

Back to loop:
    condition: 
        a. reach end point: current_node not in adjacent_list
        b. find a loop: repeated nodes
while_loop_3. get the start_index of start in final_path list
while_loop_4. update final_path, combine the following components
    a. final_path[0: start_index + 1]
    b. trail
    c. final_path[start_index + 1:]

while_loop_5. (break point)if nothing left in adjacent_list: break, else go to step 6
while_loop_6. initate boolean found_new_start = False
while_loop_7. for loop 
    go thru each vertex in final_path, 
    (break for loop) if find a vertex in adjacent_list, define start_node with this vertex, and change found_new_start as True
    (end): if nothing is found
while_loop_8. (break point) if no found_new_start, else start while loop with updated start_node




